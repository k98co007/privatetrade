# Low Level Design (LLD)
**버전**: 1.0  
**기반**: TICKET-004 (HLD)  
**작성일**: 2026년 2월 8일  

---

## 1. 개요

이 문서는 주식투자 백테스팅 시스템의 상세 설계(LLD)를 정의한다. HLD에서 정의한 9개 컴포넌트를 모듈/클래스/함수 수준으로 상세 설계한다.

---

## 2. 프론트엔드 상세 설계

### 2.1 UI 컨트롤러 (FC-001)

#### 2.1.1 클래스 정의: `UIController`

```
클래스 UIController
  속성:
    - apiClient: APIClient
    - wsClient: WebSocketClient
    - chartRenderer: ChartRenderer
    - currentState: {blacklist[], whitelist[], strategy, selectedSymbol}
  
  메서드:
    + initialize(): void
    + onBlacklistBtnClick(): void
    + onWhitelistBtnClick(): void
    + onStrategySelect(strategy: string): void
    + onStartBacktest(): void
    + onCancelBacktest(): void
    + updateProgressUI(progress: ProgressEvent): void
    + showResults(results: ResultSummary): void
    + showTradeDetails(symbol: string): void
    + showChart(trade: TradeDetail): void
```

#### 2.1.2 주요 플로우: 백테스팅 시작

```
플로우: startBacktesting()
  입력: 없음
  출력: 없음 (API 호출 발생)

  1. currentState 검증
     - strategy 선택 확인
     - 필수 파라미터 확인
  
  2. apiClient.startBacktest(config)
     - 요청: { strategy, buy_time, sell_time, blacklist, whitelist }
     - 응답: { session_id, status: "running" }
  
  3. wsClient.connect(session_id)
     - WebSocket 연결 수립
  
  4. UI 전환: 진행상황 화면으로 전환
     - 진행률 바 표시
     - "처리 중..." 메시지 표시
```

#### 2.1.3 이벤트 핸들링

```
이벤트: onBlacklistBtnClick()
  1. blacklist 팝업 오픈
  2. apiClient.getBlacklist()로 현재 목록 로드
  3. 입력 필드에 자동완성 기능
  4. "추가" 버튼 클릭 시:
     - 중복 체크 (로컬)
     - apiClient.addBlacklist(code) 호출
     - UI 업데이트
```

#### 2.1.4 상태 관리

```
currentState = {
  blacklist: Array<string>,        // 종목코드 배열
  whitelist: Array<string>,        // 종목코드 배열
  strategy: {
    type: "daily_trading" | "trailing_stop",
    params: { buy_time, sell_time, ... }
  },
  selectedSymbol: string,          // 상세 조회 선택 종목
  sessionId: string,
  progress: {
    completed: number,
    total: number,
    eta_sec: number
  }
}
```

---

### 2.2 API 클라이언트 (FC-002)

#### 2.2.1 클래스 정의: `APIClient`

```
클래스 APIClient
  속성:
    - baseUrl: string = "http://localhost:8000"
    - timeout: number = 30000
  
  비공개 메서드:
    - makeRequest(method, endpoint, body?): Promise<Response>
    - handleError(error): void
  
  공개 메서드:
    + getBlacklist(): Promise<Array>
    + addBlacklist(code: string): Promise<void>
    + removeBlacklist(code: string): Promise<void>
    + getWhitelist(): Promise<Array>
    + addWhitelist(code: string): Promise<void>
    + removeWhitelist(code: string): Promise<void>
    + startBacktest(config: BacktestConfig): Promise<{ session_id }>
    + getProgress(sessionId: string): Promise<ProgressData>
    + cancelBacktest(sessionId: string): Promise<void>
    + getResultSummary(sessionId: string): Promise<ResultSummary>
    + getSymbolResults(sessionId: string): Promise<Array>
    + getTradeDetails(sessionId: string, symbol: string): Promise<Array>
```

#### 2.2.2 메서드 구현 예시

```
메서드: addBlacklist(code: string)
  입력: code (6자리 종목코드)
  출력: Promise<void>
  
  처리:
    1. 입력 검증:
       - code 길이 확인 (6자리)
       - 숫자만 포함 여부
       - throwError if 유효하지 않음
    
    2. makeRequest("POST", "/api/blacklist/add", { code })
    
    3. 응답 처리:
       - success === true: 성공 처리
       - success === false: 오류 메시지 표시
    
    4. UI 업데이트 (이벤트 발행)
```

#### 2.2.3 오류 처리

```
오류 타입:
  - NetworkError: 네트워크 연결 실패
    → 재시도 3회 (지수 백오프)
  - ValidationError: 입력값 유효성 오류
    → 사용자에게 오류 메시지 표시
  - ServerError: 백엔드 응답 오류
    → 사용자 친화적 메시지 표시
```

---

### 2.3 WebSocket 클라이언트 (FC-003)

#### 2.3.1 클래스 정의: `WebSocketClient`

```
클래스 WebSocketClient extends EventEmitter
  속성:
    - ws: WebSocket
    - sessionId: string
    - reconnectAttempts: number = 0
    - maxReconnects: number = 3
  
  메서드:
    + connect(sessionId: string): Promise<void>
    + disconnect(): void
    - setupListeners(): void
    + on(event: string, callback: Function): void
    + emit(event: string, data: any): void
```

#### 2.3.2 메시지처리

```
이벤트: onMessage(event)
  1. JSON 파싱: const data = JSON.parse(event.data)
  
  2. 이벤트 타입 확인:
     - event === "progress":
       → emit("progress", { completed, total, current_symbol, eta_sec })
     
     - event === "completed":
       → emit("completed", { total_profit, profit_rate_pct })
     
     - event === "error":
       → emit("error", { error_code, message })
```

#### 2.3.3 재연결 로직

```
메서드: connect(sessionId: string)
  1. ws = new WebSocket("ws://localhost:8000")
  
  2. ws.onopen = () => {
       send({ action: "subscribe", session_id: sessionId })
     }
  
  3. ws.onclose = () => {
       if (reconnectAttempts < maxReconnects) {
         setTimeout(() => connect(sessionId), 1000 * (2 ^ reconnectAttempts))
         reconnectAttempts++
       } else {
         emit("error", { code: "CONNECTION_LOST" })
       }
     }
```

---

### 2.4 차트 렌더러 (FC-004)

#### 2.4.1 클래스 정의: `ChartRenderer`

```
클래스 ChartRenderer
  속성:
    - chart: TradingViewChart
    - container: HTMLElement
    - currentSeries: CandleSeries
  
  메서드:
    + render(ohlcData: Array, trades: Array): void
    + addTradeMark(type: "buy" | "sell", price, time): void
    + setZoom(level: number): void
    + export(format: "png" | "svg"): Blob
```

#### 2.4.2 데이터 포맷

```
입력 데이터:
  ohlcData: [
    {
      time: 1675246200,  // Unix timestamp
      open: 70000,
      high: 71000,
      low: 69500,
      close: 70500,
      volume: 1000000
    },
    ...
  ]
  
  trades: [
    {
      buy_time: 1675246200,
      buy_price: 70000,
      sell_time: 1675247400,
      sell_price: 70500
    },
    ...
  ]
```

#### 2.4.3 매수/매도 마커 구현

```
메서드: addTradeMark(type: "buy" | "sell", price, time)
  1. 마커 객체 생성:
     marker = {
       time: time,
       position: type === "buy" ? "belowBar" : "aboveBar",
       color: type === "buy" ? "green" : "red",
       shape: "triangle",
       size: "large"
     }
  
  2. 마커 텍스트 추가:
     marker.text = type === "buy" ? "매수" : "매도"
  
  3. 차트에 마커 추가:
     currentSeries.addMarker(marker)
```

---

## 3. 백엔드 상세 설계

### 3.1 API 라우터 (BC-001)

#### 3.1.1 라우팅 구조

```
라우터: blacklist.js
  GET /api/blacklist
    → blacklistController.getAll()
    
  POST /api/blacklist/add
    → validation.validate(body, schema)
    → blacklistController.add(req.body.code)
    
  DELETE /api/blacklist/{code}
    → blacklistController.remove(req.params.code)

라우터: strategy.js
  POST /api/strategy/config
    → validation.validate(body, strategySchema)
    → strategyController.saveConfig(body)
    → response: { config_id }
```

#### 3.1.2 요청/응답 검증

```
스키마: blacklistAddSchema
  {
    code: {
      type: "string",
      length: 6,
      pattern: "/^[0-9]{6}$/"
    }
  }

검증 함수:
  function validate(body, schema): boolean | Error
    for each field in schema:
      if not matches(body[field], schema[field]):
        throw ValidationError
    return true
```

---

### 3.2 BacktestEngine (BC-002)

#### 3.2.1 클래스 정의: `BacktestEngine`

```
클래스 BacktestEngine
  속성:
    - sessions: Map<sessionId, Session>
    - symbolQueue: Queue<string>
    - dataManager: DataManager
    - resultProcessor: ResultProcessor
    - wsManager: WebSocketManager
  
  메서드:
    + start(sessionId, config, symbols): Promise<void>
    + cancel(sessionId): void
    - processSymbol(sessionId, symbol): Promise<TradeResult>
    - broadcastProgress(sessionId): void
```

#### 3.2.2 시뮬레이션 플로우

```
메서드: start(sessionId, config, symbols)
  입력: sessionId, config { strategy, params }, symbols[]
  출력: Promise<void>
  
  처리:
    1. 세션 객체 생성:
       session = {
         sessionId,
         status: "running",
         startTime: now(),
         symbols: symbols,
         completedSymbols: 0,
         results: []
       }
       sessions.set(sessionId, session)
    
    2. 심볼 큐 생성:
       for each symbol in symbols:
         symbolQueue.enqueue(symbol)
    
    3. 워커 스레드 생성 (선택 사항):
       for i = 0 to numWorkers - 1:
         startWorker(sessionId) // 병렬 처리 (최대 4개)
    
    4. 각 워커에서:
       while symbolQueue.hasNext():
         symbol = symbolQueue.dequeue()
         result = processSymbol(sessionId, symbol)
         session.results.push(result)
         session.completedSymbols++
         broadcastProgress(sessionId)
    
    5. 완료:
       session.status = "completed"
       finalizeResults(sessionId)
```

#### 3.2.3 진행상황 브로드캐스트

```
메서드: broadcastProgress(sessionId)
  session = sessions.get(sessionId)
  
  message = {
    event: "progress",
    session_id: sessionId,
    total_symbols: session.symbols.length,
    completed_symbols: session.completedSymbols,
    current_symbol: sessions.currentSymbol,
    elapsed_time_sec: now() - session.startTime,
    eta_sec: calculateETA(session)
  }
  
  wsManager.broadcast(message)
```

---

### 3.3 StrategyExecutor (BC-003)

#### 3.3.1 클래스 정의: `StrategyExecutor`

```
클래스 StrategyExecutor
  메서드:
    + execute(strategy: string, params, ohlcData, seedMoney): Array<Trade>
    - executeStrategy1(params, ohlcData, seedMoney): Array<Trade>
    - executeStrategy2(params, ohlcData, seedMoney): Array<Trade>
```

#### 3.3.2 전략 1: 고정시간 매수/매도

```
메서드: executeStrategy1(params, ohlcData, seedMoney)
  입력:
    params = { buy_time: "10:00", sell_time: "15:00" }
    ohlcData = 60일치 2분 봉 데이터
    seedMoney = 10,000,000원
  
  출력: Array<Trade>
  
  처리:
    trades = []
    balance = seedMoney
    lossAmount = 0  // 누적 손해액
    
    for each day in ohlcData.grouped_by_date():
      // 매수 시점 찾기
      buyCandle = day.find(candle.time === buy_time)
      if buyCandle not exist:
        continue  // 이 날은 매수 불가
      
      buyPrice = buyCandle.close
      buyAmount = balance - lossAmount  // 씨드머니 적용
      
      // 매도 시점 찾기
      sellCandle = day.find(candle.time === sell_time)
      if sellCandle not exist:
        continue
      
      sellPrice = sellCandle.close
      
      // 거래 결과 계산
      grossProfit = (sellPrice - buyPrice) * (buyAmount / buyPrice)
      cost = sellPrice * buyAmount * 0.2 / 100 + sellPrice * buyAmount * 0.011 / 100  // 세금+수수료
      netProfit = grossProfit - cost
      
      balance += netProfit
      if netProfit < 0:
        lossAmount += abs(netProfit)
      
      // 거래 기록
      trade = {
        buy_time: buyCandle.time,
        buy_price: buyPrice,
        sell_time: sellCandle.time,
        sell_price: sellPrice,
        profit: netProfit,
        cost: cost
      }
      trades.append(trade)
    
    return trades
```

#### 3.3.3 전략 2: Trailing Stop

```
메서드: executeStrategy2(params, ohlcData, seedMoney)
  입력:
    params = {
      buy_time: "15:30",
      min_profit_pct: 1.0,
      profit_cutoff_pct: 80.0,
      loss_cutoff_time: "다음날 14:00"
    }
    ohlcData: 60일치 2분 봉
    seedMoney: 10,000,000원
  
  출력: Array<Trade>
  
  처리:
    trades = []
    balance = seedMoney
    lossAmount = 0
    
    for each day in ohlcData:
      // Step 1: 매수
      buyCandle = day.find(candle.time === buy_time)
      if buyCandle not exist:
        continue
      
      buyPrice = buyCandle.close
      buyAmount = balance - lossAmount
      
      // Step 2: 다음날 손절/익절 찾기
      nextDay = ohlcData[day + 1]
      
      // 손절 시간 찾기 (다음날 14:00)
      lossCandle = nextDay.find(candle.time === loss_cutoff_time)
      
      // 최소 수익 확인
      minProfitReached = false
      for each candle in nextDay:
        candlePrice = candle.close
        profitRate = (candlePrice - buyPrice) / buyPrice * 100
        
        if profitRate >= min_profit_pct:
          minProfitReached = true
          highestPrice = max(highestPrice, candlePrice)
        
        // 손절 시간 도달 && 최소 수익 미달
        if candle.time >= loss_cutoff_time and not minProfitReached:
          // 손절 실행
          sellPrice = lossCandle.close
          break
        
        // 이익보전(Trailing Stop) 로직
        if minProfitReached and (highestPrice - candlePrice) / highestPrice > (1 - profit_cutoff_pct / 100):
          // 현재가로 매도
          sellPrice = candlePrice
          break
      
      // End of day: 미청산 시 매도
      if sellPrice not set:
        sellPrice = nextDay.last().close
      
      // 거래 결과 계산 (전략 1과 동일)
      grossProfit = (sellPrice - buyPrice) * (buyAmount / buyPrice)
      cost = sellPrice * buyAmount * 0.2 / 100 + sellPrice * buyAmount * 0.011 / 100  // 세금+수수료
      netProfit = grossProfit - cost
      
      balance += netProfit
      if netProfit < 0:
        lossAmount += abs(netProfit)
      
      trade = { ... }
      trades.append(trade)
    
    return trades
```

---

### 3.4 DataManager (BC-004)

#### 3.4.1 클래스 정의: `DataManager`

```
클래스 DataManager
  속성:
    - cache: Map<string, CachedData>
    - symbolList: Array<Symbol>
    - apiClient: YahooFinanceClient (외부)
  
  메서드:
    + fetchStockData(code, startDate, period): Promise<Array<OHLC>>
    + getCachedData(code): CachedData | null
    + invalidateCache(code): void
    + getSymbolList(): Promise<Array<Symbol>>
    - isCacheValid(cachedData): boolean  // 날짜 기반 판별 (SRS NFR-301: 일일 1회)
    - saveToDiskCache(code, data, date): void  // 디스크 캐시 저장
    - loadFromDiskCache(code): CachedData | null  // 디스크 캐시 조회
```

#### 3.4.2 캐싱 전략

```
메서드: fetchStockData(code, startDate, period)
  입력: code, startDate, period
  출력: Promise<Array<OHLC>>
  
  처리:
    // 1. 메모리 캐시 확인
    cachedData = cache.get(code)
    if cachedData and isCacheValid(cachedData):
      return cachedData.data
    
    // 2. 디스크 캐시 확인 (서버 재시작 시 메모리 캐시 유실 대비)
    diskData = diskCache.load(code)
    if diskData and diskData.fetchDate === today():
      cache.set(code, diskData)  // 메모리 캐시 복원
      return diskData.data
    
    // 3. 캐시 유효하지 않음 → 외부 API 호출 (Yahoo Finance)
    try:
      data = await yahooFinanceAPI.get2MinuteCandles(code, startDate, period)
    catch error:
      throw DataFetchError(code, error.message)
    
    // 캐시 저장 (일일 1회 수집 - SRS NFR-301)
    cache.set(code, {
      data: data,
      timestamp: now(),
      fetchDate: today(),  // "YYYY-MM-DD" 형식
      ttl: 86400000  // 24시간 (비상 대비 백업 TTL)
    })
    
    // 디스크 캐시에도 병행 저장 (서버 재시작 시 당일 데이터 유지)
    diskCache.save(code, data, today())
    
    return data

메서드: isCacheValid(cachedData)
  // 날짜 기반 판별: 당일 수집한 데이터면 유효
  return cachedData.fetchDate === today()
```

---

### 3.5 ResultProcessor (BC-005)

#### 3.5.1 클래스 정의: `ResultProcessor`

```
클래스 ResultProcessor
  속성:
    - resultRepository: ResultRepository
  
  메서드:
    + process(sessionId, trades, symbol): Promise<SymbolResult>
    - calculateSummary(trades): SummaryStats
    - applyCost(trade): TradeWithCost
    - calculateSeedMoneyLoss(trades): number
```

#### 3.5.2 결과 계산 로직

```
메서드: process(sessionId, trades, symbol)
  입력: sessionId, trades[], symbol
  출력: Promise<SymbolResult>
  
  처리:
    // Step 1: 비용 적용
    tradesWithCost = []
    for each trade in trades:
      trade.cost = calculateCost(trade.buy_price, trade.sell_price, trade.buy_amount)
      trade.netProfit = trade.grossProfit - trade.cost
      tradesWithCost.append(trade)
    
    // Step 2: 통계 계산
    stats = calculateSummary(tradesWithCost):
      totalProfit = sum(t.netProfit for t if t.netProfit > 0)
      totalLoss = sum(abs(t.netProfit) for t if t.netProfit < 0)
      winCount = count(t for t if t.netProfit > 0)
      lossCount = count(t for t if t.netProfit < 0)
      profitRate = (totalProfit - totalLoss) / 10000000 * 100
    
    // Step 3: 결과 저장
    result = {
      sessionId,
      symbol_code: symbol.code,
      symbol_name: symbol.name,
      trade_count: len(trades),
      win_count: stats.winCount,
      loss_count: stats.lossCount,
      total_profit: stats.totalProfit,
      total_loss: stats.totalLoss,
      profit_rate: stats.profitRate
    }
    
    await resultRepository.saveSymbolResult(result)
    
    // Step 4: 거래 상세 저장
    for each trade in tradesWithCost:
      await resultRepository.saveTradeDetail(sessionId, symbol.code, trade)
    
    return result
```

#### 3.5.3 비용 계산

```
메서드: calculateCost(buyPrice, sellPrice, buyAmount)
  // 세금: 매도금액 총액의 0.2%
  taxAmount = sellPrice * buyAmount * 0.2 / 100
  
  // 수수료: 매도금액의 0.011%
  commissionAmount = sellPrice * buyAmount * 0.011 / 100
  
  return taxAmount + commissionAmount
```

---

### 3.6 WebSocketManager (BC-006)

#### 3.6.1 클래스 정의: `WebSocketManager`

```
클래스 WebSocketManager extends EventEmitter
  속성:
    - clients: Map<sessionId, WebSocket>
  
  메서드:
    + addClient(sessionId, ws): void
    + removeClient(sessionId): void
    + broadcast(message): void
    + sendToSession(sessionId, message): void
```

#### 3.6.2 메시지 브로드캐스트

```
메서드: broadcast(message)
  입력: message = { event, session_id, data }
  
  처리:
    for each client in clients.values():
      try:
        client.send(JSON.stringify(message))
      catch error:
        // 클라이언트 연결 끊김: 제거
        removeClient(getSessionId(client))
```

---

## 4. 데이터 저장 상세 설계

### 4.1 ConfigRepository (BC-007)

#### 4.1.1 파일 기반 저장

```
파일: data/blacklist.json
구조:
  {
    "blacklist": [
      { "code": "005930", "name": "삼성전자" },
      { "code": "000660", "name": "SK하이닉스" }
    ]
  }

파일: data/whitelist.json
구조:
  {
    "whitelist": [
      { "code": "066570", "name": "삼성전자우" }
    ]
  }

파일: data/strategy_config.json
구조:
  {
    "configs": [
      {
        "config_id": "cfg_001",
        "strategy": "daily_trading",
        "params": {
          "buy_time": "10:00",
          "sell_time": "15:00"
        },
        "created_at": "2026-02-08T12:00:00Z"
      }
    ]
  }
```

---

### 4.2 ResultRepository (BC-008)

#### 4.2.1 SQL 쿼리

```
테이블: backtest_session
쿼리: SELECT * FROM backtest_session WHERE session_id = ?
구현:
  const result = await db.get(
    "SELECT * FROM backtest_session WHERE session_id = ?",
    [sessionId]
  )
  return result

테이블: trade_detail
쿼리: INSERT INTO trade_detail (...)
구현:
  const stmt = db.prepare(
    "INSERT INTO trade_detail (session_id, symbol_code, trade_sequence, " +
    "buy_time, buy_price, sell_time, sell_price, profit, cost_amount, net_profit) " +
    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
  )
  
  stmt.run(
    sessionId,
    symbol_code,
    trade_sequence,
    buy_time,
    buy_price,
    sell_time,
    sell_price,
    profit,
    cost_amount,
    net_profit
  )
```

---

## 5. 시퀀스 다이어그램

### 5.1 사용자가 백테스팅 시작하는 플로우

```
순서도:
1. 사용자 "백테스팅 시작" 버튼 클릭
2. UIController.onStartBacktest() 호출
3. APIClient.startBacktest(config) 호출
4. 백엔드 /api/backtest/start 엔드포인트 수신
5. BacktestEngine.start(sessionId, config, symbols) 실행
6. 각 종목별 StrategyExecutor.execute() 실행
7. DataManager.fetchStockData() 호출 (Yahoo Finance에서 데이터 수집)
8. 거래 내역 계산
9. ResultProcessor.process() 호출하여 결과 저장
10. WebSocketManager.broadcast(progress) 호출
11. 클라이언트가 WebSocket으로 progress 수신
12. UIController.updateProgressUI() 업데이트
13. 모든 종목 완료 시 BacktestEngine broadcast(completed)
14. 클라이언트가 결과 페이지로 전환
```

---

## 6. 예외 처리 및 에러 코드

### 6.1 에러 코드 정의

```
DATA_FETCH_ERROR (1000):
  - 원인: Yahoo Finance 데이터 수집 실패
  - 처리: 해당 종목 스킵, 로그 기록
  
INVALID_CONFIG_ERROR (2000):
  - 원인: 전략 설정값 유효성 오류
  - 처리: 사용자에게 오류 메시지 표시
  
CALCULATION_ERROR (3000):
  - 원인: 거래 계산 중 오류
  - 처리: 해당 종목 스킵, 로그 기록
  
DB_ERROR (4000):
  - 원인: 데이터베이스 저장 실패
  - 처리: 롤백, 사용자에게 오류 메시지 표시
  
CONNECTION_LOST (5000):
  - 원인: WebSocket 연결 끊김
  - 처리: 자동 재연결 3회 시도
```

### 6.2 오류 처리 패턴

```
try-catch 패턴:
  try:
    result = await backtest_engine.start(sessionId, config, symbols)
  catch DataFetchError as e:
    log_error(e)
    ws_manager.broadcast({
      event: "error",
      session_id: sessionId,
      error_code: "DATA_FETCH_ERROR",
      message: "데이터 수집 실패: " + e.symbol
    })
    // 백테스팅 계속 진행 (해당 종목만 스킵)
  catch DBError as e:
    log_error(e)
    ws_manager.broadcast({
      event: "error",
      session_id: sessionId,
      error_code: "DB_ERROR",
      message: "저장 실패"
    })
    // 백테스팅 중단
    return
```

---

## 7. 수도코드

### 7.1 메인 백테스팅 플로우

```
함수 main_backtest(config, symbols):
  session = create_session()
  
  for symbol in symbols:
    try:
      // 데이터 수집
      ohlc_data = fetch_stock_data(symbol)
      
      // 전략 실행
      trades = execute_strategy(config.strategy, ohlc_data)
      
      // 결과 계산
      result = process_result(trades)
      
      // 저장
      save_result(session, symbol, result)
      
      // 진행상황 브로드캐스트
      broadcast_progress(session)
      
    except DataFetchError:
      log_skip_symbol(symbol)
      continue
    except Exception as e:
      log_error(symbol, e)
      continue
  
  finalize_session(session)
  broadcast_completed(session)
```

---

## 8. 개발자 체크리스트

- [ ] 모든 클래스 및 메서드 구현
- [ ] 단위 테스트 작성 (커버리지 >= 80%)
- [ ] 통합 테스트 작성
- [ ] 오류 처리 검증
- [ ] 성능 테스트 (200개 종목 5분 이내)
- [ ] 코드 리뷰 완료

---

## 승인 및 서명

- **작성자**: LLD 아키텍처 담당자
- **리뷰어**: 실무 개발 담당자
- **최종 승인**: 프로젝트 매니저


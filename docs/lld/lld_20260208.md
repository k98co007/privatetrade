# Low Level Design (LLD) - v2.0
**버전**: 2.0  
**기반**: TICKET-009 (HLD 1.1)  
**작성일**: 2026년 2월 8일  
**변경 사항**: 특정 종목 선택 기능 상세 설계 (StockFilter, ConfigRepository, DataManager 확장)  

---

## 1. 신규 컴포넌트: StockFilter

### 1.1 클래스 정의
```javascript
class StockFilter {
  /**
   * 특정 종목 필터링 모듈
   * 역할: stock_mode에 따라 종목 리스트 필터링
   */

  constructor(kospi200List) {
    this.kospi200List = kospi200List; // KOSPI 200 전체 종목 코드 배열
  }

  /**
   * @param {string} mode - 'all' | 'filtered' | 'specific'
   * @param {array} blacklist - 블랙리스트 종목 코드
   * @param {array} whitelist - 화이트리스트 종목 코드
   * @param {array} specificStocks - 특정 종목 코드 (mode='specific'일 때만)
   * @returns {array} 필터링된 종목 코드 배열
   */
  applyFilter(mode, blacklist = [], whitelist = [], specificStocks = []) {
    switch (mode) {
      case 'all':
        return this.kospi200List;
      
      case 'filtered':
        return this.applyBlackWhiteFilter(blacklist, whitelist);
      
      case 'specific':
        return this.applySpecificFilter(specificStocks);
      
      default:
        throw new Error(`Unknown stock_mode: ${mode}`);
    }
  }

  /**
   * 블랙/화이트리스트 필터링
   */
  applyBlackWhiteFilter(blacklist, whitelist) {
    let result = this.kospi200List.filter(code => !blacklist.includes(code));
    if (whitelist.length > 0) {
      result = [...new Set([...result, ...whitelist])];
    }
    return result;
  }

  /**
   * 특정 종목만 필터링
   */
  applySpecificFilter(specificStocks) {
    // 요청된 종목이 유효한 종목 코드인지 검증
    const invalidCodes = specificStocks.filter(code => !this.isValidStockCode(code));
    if (invalidCodes.length > 0) {
      throw new StockValidationError(`Invalid stock codes: ${invalidCodes.join(',')}`);
    }
    
    // KOSPI 200 + 화이트리스트에서 요청된 종목만 필터링
    return specificStocks.filter(code =>
      this.kospi200List.includes(code) || this.isWhitelistStock(code)
    );
  }

  /**
   * 종목 코드 유효성 검증 (6자리 숫자)
   */
  isValidStockCode(code) {
    return /^\d{6}$/.test(code);
  }

  /**
   * 화이트리스트 종목 여부 확인
   */
  isWhitelistStock(code) {
    // ConfigRepository에서 화이트리스트 조회
    // (다른 모듈과의 의존성으로 인해 주입받음)
    return this.whitelistStocks?.includes(code) || false;
  }
}
```

### 1.2 사용 예시
```javascript
// DataManager에서 사용
const stockFilter = new StockFilter(kospi200Codes);
const filteredStocks = stockFilter.applyFilter(
  'specific',
  [],
  [],
  ['005930', '000660'] // 삼성전자, SK하이닉스
);
// 반환: ['005930', '000660']
```

---

## 2. 수정: ConfigRepository 확장

### 2.1 클래스 수정 사항
```javascript
class ConfigRepository {
  /**
   * 기존 메서드 유지
   * + 신규 필드 관리
   */

  // ✓ 기존 메서드
  async getBlacklist() { ... }
  async addToBlacklist(code) { ... }
  async removeFromBlacklist(code) { ... }
  
  // ✓ 기존 메서드
  async getWhitelist() { ... }
  async addToWhitelist(code) { ... }
  async removeFromWhitelist(code) { ... }

  // ✓ 기존 메서드
  async getStrategy(configId) { ... }
  async saveStrategy(strategy) { ... }

  // [신규] stock_mode 관리
  async updateStockMode(mode) {
    /**
     * @param {string} mode - 'all' | 'filtered' | 'specific'
     */
    const query = `UPDATE config SET stock_mode = ? WHERE id = ?`;
    const result = await db.run(query, [mode, this.currentConfigId]);
    return result.lastID > 0;
  }

  async getStockMode() {
    const query = `SELECT stock_mode FROM config WHERE id = ?`;
    const result = await db.get(query, [this.currentConfigId]);
    return result?.stock_mode || 'all';
  }

  // [신규] 특정 종목 관리
  async updateSpecificStocks(stockCodes) {
    /**
     * @param {array} stockCodes - 특정 종목 코드 배열
     */
    const jsonStr = JSON.stringify(stockCodes);
    const query = `UPDATE config SET selected_specific_stocks = ? WHERE id = ?`;
    const result = await db.run(query, [jsonStr, this.currentConfigId]);
    return result.lastID > 0;
  }

  async getSpecificStocks() {
    const query = `SELECT selected_specific_stocks FROM config WHERE id = ?`;
    const result = await db.get(query, [this.currentConfigId]);
    if (!result?.selected_specific_stocks) return [];
    try {
      return JSON.parse(result.selected_specific_stocks);
    } catch (e) {
      console.error('Failed to parse selected_specific_stocks', e);
      return [];
    }
  }

  async clearSpecificStocks() {
    const query = `UPDATE config SET selected_specific_stocks = NULL WHERE id = ?`;
    await db.run(query, [this.currentConfigId]);
  }
}
```

### 2.2 SQL 마이그레이션 스크립트
```sql
-- migration_20260208_add_specific_stocks.sql
ALTER TABLE config ADD COLUMN stock_mode TEXT DEFAULT 'all';
ALTER TABLE config ADD COLUMN selected_specific_stocks TEXT;

-- 기존 설정들은 'all' 모드로 초기화
UPDATE config SET stock_mode = 'all' WHERE stock_mode IS NULL;
```

---

## 3. 수정: DataManager

### 3.1 메서드 수정 사항
```javascript
class DataManager {
  // ✓ 기존 메서드
  async fetchYahooData(ticker, period) { ... }
  
  // ✓ 기존 메서드
  async getCachedData(ticker) { ... }

  // [수정] 종목 리스트 조회 메서드 개선
  async getBacktestStocks(configId) {
    /**
     * HLD 1.1의 의도:
     * 1. configRepository에서 stock_mode 읽음
     * 2. stock_mode에 따라 StockFilter 호출
     * 3. 필터링된 종목 리스트 반환
     */
    const configRepo = new ConfigRepository();
    const mode = await configRepo.getStockMode();
    const blacklist = await configRepo.getBlacklist();
    const whitelist = await configRepo.getWhitelist();
    const specificStocks = await configRepo.getSpecificStocks();

    const stockFilter = new StockFilter(this.kospi200Codes);
    const filteredStocks = stockFilter.applyFilter(
      mode,
      blacklist,
      whitelist,
      specificStocks
    );

    return filteredStocks;
  }

  /**
   * [신규] 특정 종목의 Yahoo 데이터 대량 수집
   */
  async fetchDataForSpecificStocks(stockCodes) {
    /**
     * @param {array} stockCodes - 특정 종목 코드 배열
     * @returns {object} { code: yahooData }
     */
    const dataMap = {};
    for (const code of stockCodes) {
      try {
        const ticker = this.codeToTicker(code); // 코드 → ticker 변환
        dataMap[code] = await this.fetchYahooData(ticker, 60); // 60일치
      } catch (error) {
        console.error(`Failed to fetch data for ${code}:`, error);
        dataMap[code] = null;
      }
    }
    return dataMap;
  }
}
```

---

## 4. 수정: BacktestEngine

### 4.1 메서드 수정 사항
```javascript
class BacktestEngine {
  /**
   * [수정] 백테스팅 실행 메서드
   * - stock_mode 파라미터 추가
   */
  async start(config, stockMode = 'all', selectedStocks = []) {
    /**
     * @param {object} config - 전략 설정 (buy_time, sell_time 등)
     * @param {string} stockMode - 'all' | 'filtered' | 'specific'
     * @param {array} selectedStocks - 특정 종목 코드 (stockMode='specific'일 때)
     */

    // 1. DataManager에서 필터링된 종목 리스트 조회
    const dataManager = new DataManager();
    let backtestStocks;
    
    if (stockMode === 'specific') {
      // 특정 종목만 백테스팅
      backtestStocks = selectedStocks;
    } else {
      // 기존 로직: 'all' 또는 'filtered' 모드의 종목 리스트 조회
      backtestStocks = await dataManager.getBacktestStocks();
    }

    // 2. 각 종목별 백테스팅 실행
    const results = [];
    const totalStocks = backtestStocks.length;

    for (let i = 0; i < backtestStocks.length; i++) {
      const stock = backtestStocks[i];
      
      // 진행상황 실시간 업데이트 (WebSocket)
      this.emitProgress({
        total: totalStocks,
        completed: i,
        current_stock: stock,
        progress_pct: Math.round((i / totalStocks) * 100),
        stock_mode: stockMode
      });

      try {
        // Python 백테스팅 엔진 호출
        const result = await this.callPythonBacktest(stock, config);
        results.push({
          code: stock,
          result: result,
          status: 'success'
        });
      } catch (error) {
        console.error(`Backtest failed for ${stock}:`, error);
        results.push({
          code: stock,
          status: 'failed',
          error: error.message
        });
      }
    }

    // 3. 결과 저장
    return this.processResults(results, stockMode, selectedStocks);
  }

  /**
   * [신규] 진행상황 이벤트 발생
   */
  emitProgress(progressData) {
    // WebSocketManager에 브로드캐스트
    this.wsManager.broadcast('backtest-progress', progressData);
  }

  /**
   * [신규] Python 백테스팅 엔진 호출
   */
  async callPythonBacktest(stockCode, strategy) {
    // 또는 exec('python backtest.py ...')로 구현
    // 여기서는 인터페이스만 정의
    return await pythonWorker.execute({
      stock_code: stockCode,
      strategy: strategy,
      period: 60,
      initial_capital: 10000000
    });
  }

  /**
   * [수정] 결과 후처리
   */
  async processResults(results, stockMode, selectedStocks) {
    const resultProcessor = new ResultProcessor();
    
    // stock_mode 및 selectedStocks 메타데이터 저장
    return await resultProcessor.save({
      results: results,
      stock_mode: stockMode,
      selected_stocks: selectedStocks,
      created_at: new Date()
    });
  }
}
```

---

## 5. Python 백테스팅 엔진 설계

### 5.1 모듈 위치 및 실행 방식

**File**: `backtest_engine.py` (백엔드 루트의 `py_backtest/` 디렉토리)

```python
# Execution method: Node.js에서 Python Worker로 호출
# 또는 exec('python py_backtest/backtest_engine.py ...')

import sys
import json
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Tuple
```

### 5.2 BacktestEngine 클래스 설계

```python
class BacktestEngine:
    """
    주식 백테스팅 엔진
    - 특정 기간의 주가 데이터를 기반으로 매매 시뮬레이션
    - 수익률, 승률, MDD 등 성과 지표 계산
    """
    
    def __init__(self, stock_code: str, initial_capital: float = 10000000):
        """
        @param stock_code: 종목 코드 (예: "005930")
        @param initial_capital: 초기 자본금 (기본값: 1천만원)
        """
        self.stock_code = stock_code
        self.initial_capital = initial_capital
        self.current_cash = initial_capital
        self.positions = []  # 보유 중인 포지션 기록
        self.trading_log = []  # 모든 거래 로그
        self.equity_curve = []  # 자산 추이
    
    def load_price_data(self, period: int = 60) -> pd.DataFrame:
        """
        Yahoo Finance에서 주가 데이터 수집
        
        @param period: 조회 기간 (일 단위, 기본값: 60일)
        @return: OHLCV 데이터프레임 (Date, Open, High, Low, Close, Volume)
        
        [수정사항 - HLD 1.0 기반]
        HLD BC-004 DataManager의 fetchStockData와 동일 기능 수행
        - Yahoo Finance에서 2분 봉(2min) 데이터 조회
        - 시작일: 오늘로부터 period일 이전
        - 종료일: 오늘
        
        @실행 흐름:
        1. yfinance 라이브러리로 Yahoo Finance API 호출
        2. 한국 종목 코드 → Ticker 변환 (예: "005930" → "000001.KS")
        3. 2분 봉 데이터 조회 및 OHLCV 포맷 변환
        4. 데이터 검증 및 정렬
        """
        import yfinance as yf
        
        try:
            # 1. 종목 코드 변환 (Korean Code → Yahoo Ticker)
            # 형식: 6자리 코드.KS (KOSPI) or .KQ (KOSDAQ)
            ticker = self._convert_to_ticker(self.stock_code)
            
            # 2. Yahoo Finance에서 데이터 조회
            logger.info(f"Fetching data for {ticker} (period={period}d)...")
            df = yf.download(
                ticker, 
                period=f"{period}d",
                interval="2m",  # 2분 봉
                progress=False,
                prepost=False   # 장중 시간만 (09:30 ~ 15:50)
            ).reset_index()
            
            # 3. 컬럼 정렬 및 이름 변환
            df.columns = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']
            df['Date'] = pd.to_datetime(df['Date'])
            df = df.sort_values('Date').reset_index(drop=True)
            
            logger.info(f"Successfully loaded {len(df)} records for {self.stock_code}")
            return df
            
        except Exception as e:
            logger.error(f"Error fetching price data for {self.stock_code}: {str(e)}")
            raise ValueError(f"Failed to fetch Yahoo Finance data: {str(e)}")
    
    def _convert_to_ticker(self, stock_code: str, market: str = None) -> str:
        """
        한국 종목 코드를 Yahoo Finance Ticker로 변환
        
        @param stock_code: KRX 종목 코드 (예: "005930", "066570")
        @param market: 시장 구분 ('KS'=KOSPI, 'KQ'=KOSDAQ, None=자동감지)
        @return: Yahoo Finance Ticker (예: "005930.KS", "066570.KQ")
        
        주의: 한국 종목 코드는 숫자 범위로 KOSPI/KOSDAQ를 구별할 수 없음.
        예: 005930(삼성전자, KOSPI), 035420(NAVER, KOSPI) 모두 숫자값 > 4000.
        
        변환 방식:
        1. market 파라미터가 명시된 경우: 해당 suffix 사용
        2. market 미지정 시: yfinance로 .KS → .KQ 순서로 조회하여 자동 판별
        3. 조회 실패 시: 기본값 .KS (KOSPI) 사용
        """
        if market in ('KS', 'KQ'):
            return f"{stock_code}.{market}"
        
        # yfinance로 .KS 우선 시도, 실패 시 .KQ
        for suffix in ['KS', 'KQ']:
            candidate = f"{stock_code}.{suffix}"
            try:
                hist = yf.Ticker(candidate).history(period='1d')
                if hist is not None and not hist.empty:
                    return candidate
            except Exception:
                continue
        
        # 기본값: .KS (KOSPI)
        return f"{stock_code}.KS"
    
    def run_backtest(self, strategy: Dict, period: int = 60) -> Dict:
        """
        백테스팅 실행 (Yahoo Finance 데이터 기반)
        
        @param strategy: 전략 설정 {
          "buy_time": "09:30",      # 매수 시간
          "sell_time": "15:50",     # 매도 시간
          "hold_period": 1          # 보유 기간 (일, 기본값: 1 = 당일)
        }
        @param period: 조회 기간 (일 단위, 기본값: 60일)
        @return: 백테스팅 결과 (수익률, 승률, MDD 등)
        """
        # 1. Yahoo Finance에서 데이터 수집 (HLD BC-004 DataManager 역할)
        prices = self.load_price_data(period=period)
        
        if prices.empty:
            raise ValueError(f"No price data available for {self.stock_code}")
        
        logger.info(f"Backtest start: {self.stock_code}, Period: {period}d, Data points: {len(prices)}")
        
        # 2. 거래 신호 생성
        buy_signals, sell_signals = self.generate_signals(prices, strategy)
        
        # 3. 주문 실행
        for idx, row in prices.iterrows():
            date = row['Date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(row['Date'], 'strftime') else str(row['Date'])
            close_price = float(row['Close'])
            
            if idx in buy_signals:
                max_quantity = int(self.current_cash / close_price)
                if max_quantity > 0:
                    self.buy(date, close_price, quantity=max_quantity)
                else:
                    logger.warning(f"Insufficient cash at {date}: {self.current_cash} < {close_price}")
            elif idx in sell_signals:
                self.sell(date, close_price)
        
        # 4. 결과 계산
        return self.calculate_performance()
    
    def generate_signals(self, prices: pd.DataFrame, strategy: Dict) -> Tuple[List, List]:
        """
        매매 신호 생성 (구매/판매 시점)
        
        @param strategy 기반:
        - buy_time: 매수 시간 (예: "09:30")
        - sell_time: 매도 시간 (예: "15:50")
        - hold_period: 보유 기간 (일 단위, 기본값: 1) → 당일 반복매매
        
        @return: (buy_signals_list, sell_signals_list)
        """
        buy_signals = []
        sell_signals = []
        
        for date, row in prices.iterrows():
            time = date.strftime('%H:%M')
            
            # 매수 신호
            if time == strategy['buy_time']:
                buy_signals.append(date)
            
            # 매도 신호
            if time == strategy['sell_time']:
                sell_signals.append(date)
        
        return buy_signals, sell_signals
    
    def buy(self, date: datetime, price: float, quantity: int = 1):
        """
        매수 주문 실행
        
        @param date: 거래 날짜
        @param price: 거래 가격
        @param quantity: 수량
        """
        cost = price * quantity
        if self.current_cash >= cost:
            self.current_cash -= cost
            self.positions.append({
                'entry_date': date,
                'entry_price': price,
                'quantity': quantity,
                'type': 'long'
            })
            self.trading_log.append({
                'date': date,
                'type': 'BUY',
                'price': price,
                'quantity': quantity,
                'cost': cost,
                'cash_remaining': self.current_cash
            })
    
    def sell(self, date: datetime, price: float):
        """
        매도 주문 실행 (FIFO 방식)
        
        @param date: 거래 날짜
        @param price: 거래 가격
        """
        if not self.positions:
            return
        
        position = self.positions.pop(0)  # FIFO
        proceeds = price * position['quantity']
        profit = proceeds - (position['entry_price'] * position['quantity'])
        
        self.current_cash += proceeds
        self.trading_log.append({
            'date': date,
            'type': 'SELL',
            'price': price,
            'quantity': position['quantity'],
            'proceeds': proceeds,
            'profit': profit,
            'profit_rate': (profit / (position['entry_price'] * position['quantity'])) * 100,
            'cash_remaining': self.current_cash
        })
    
    def calculate_performance(self) -> Dict:
        """
        백테스팅 성과 지표 계산
        
        @return: 수익률, 승률, MDD, Sharpe Ratio 등
        """
        total_trades = len([t for t in self.trading_log if t['type'] == 'SELL'])
        winning_trades = len([t for t in self.trading_log if t['type'] == 'SELL' and t['profit'] > 0])
        losing_trades = total_trades - winning_trades
        
        total_profit = sum([t.get('profit', 0) for t in self.trading_log])
        return_rate = (total_profit / self.initial_capital) * 100
        
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
        avg_win = sum([t['profit'] for t in self.trading_log if t['type'] == 'SELL' and t['profit'] > 0]) / winning_trades if winning_trades > 0 else 0
        avg_loss = abs(sum([t['profit'] for t in self.trading_log if t['type'] == 'SELL' and t['profit'] <= 0])) / losing_trades if losing_trades > 0 else 0
        
        # MDD (최대한낙률) 계산
        equity_curve = self.calculate_equity_curve()
        mdd = self.calculate_mdd(equity_curve)
        
        return {
            'stock_code': self.stock_code,
            'total_profit': total_profit,
            'return_rate': return_rate,
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': losing_trades,
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'profit_factor': avg_win / avg_loss if avg_loss > 0 else 0,
            'mdd': mdd,
            'final_capital': self.current_cash + sum([p['entry_price'] * p['quantity'] for p in self.positions]),
            'trading_log': self.trading_log
        }
    
    def calculate_equity_curve(self) -> List[float]:
        """자산 추이 계산"""
        equity = [self.initial_capital]
        for trade in self.trading_log:
            equity.append(trade['cash_remaining'])
        return equity
    
    def calculate_mdd(self, equity_curve: List[float]) -> float:
        """Maximum Drawdown 계산"""
        peak = equity_curve[0]
        mdd = 0
        for value in equity_curve:
            if value > peak:
                peak = value
            dd = (peak - value) / peak * 100
            if dd > mdd:
                mdd = dd
        return mdd
```

### 5.3 실행 인터페이스

**호출 방식**: Node.js pythonWorker에서 호출 또는 subprocess 실행

```python
# main.py 또는 node.js pythonWorker에서의 호출

if __name__ == '__main__':
    import json
    import sys
    
    # Node.js/Backend에서 전달받은 데이터 파싱
    input_data = json.loads(sys.argv[1])
    # 형식: {
    #   "stock_code": "005930",
    #   "strategy": {
    #     "buy_time": "09:30",
    #     "sell_time": "15:50",
    #     "hold_period": 1
    #   },
    #   "period": 60,                    # 조회 기간 (일)
    #   "initial_capital": 10000000
    # }
    
    stock_code = input_data.get('stock_code')
    strategy = input_data.get('strategy', {})
    period = input_data.get('period', 60)  # 기본값: 60일
    initial_capital = input_data.get('initial_capital', 10000000)
    
    try:
        # 1. BacktestEngine 초기화
        engine = BacktestEngine(stock_code, initial_capital)
        
        # 2. Yahoo Finance에서 데이터 수집 & 시뮬레이션 실행
        result = engine.run_backtest(strategy, period=period)
        
        # 3. JSON 형식으로 결과 반환
        print(json.dumps(result, indent=2))
        
    except Exception as e:
        # 오류 발생 시 JSON 오류 메시지 출력
        error_response = {
            "status": "error",
            "stock_code": stock_code,
            "error_message": str(e)
        }
        print(json.dumps(error_response))
        sys.exit(1)
```

**Backend (Node.js) 호출 예시**:

```javascript
// backend/utils/pythonWorker.js
const { spawn } = require('child_process');

async function executeBacktest(stock_code, strategy, period = 60, initial_capital = 10000000) {
  const inputData = {
    stock_code,
    strategy,
    period,
    initial_capital
  };
  
  return new Promise((resolve, reject) => {
    const python = spawn('python', ['py_backtest/backtest_engine.py', JSON.stringify(inputData)]);
    
    let output = '';
    python.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    python.stderr.on('data', (data) => {
      console.error(`Python Error: ${data}`);
    });
    
    python.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Python process exited with code ${code}`));
      } else {
        try {
          const result = JSON.parse(output);
          resolve(result);
        } catch (e) {
          reject(new Error(`Failed to parse backtest result: ${e.message}`));
        }
      }
    });
  });
}

module.exports = { executeBacktest };
```

---

## 6. API 엔드포인트 상세 설계 (4개)

### 6.1 라우트 정의 (Express)
```javascript
// backend/routes/stocks.js

const express = require('express');
const router = express.Router();
const ConfigRepository = require('../repositories/ConfigRepository');
const StockFilter = require('../modules/StockFilter');

/**
 * POST /api/stocks/mode
 * 종목 선택 모드 전환
 */
router.post('/mode', async (req, res) => {
  try {
    const { mode } = req.body;
    
    // 유효성 검사
    if (!['all', 'filtered', 'specific'].includes(mode)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid stock_mode. Must be: all, filtered, or specific'
      });
    }

    const configRepo = new ConfigRepository();
    await configRepo.updateStockMode(mode);
    
    // 모드 전환 시 특정 종목 초기화
    if (mode !== 'specific') {
      await configRepo.clearSpecificStocks();
    }

    res.json({
      success: true,
      current_mode: mode
    });
  } catch (error) {
    console.error('/api/stocks/mode error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * POST /api/stocks/specific/add
 * 특정 종목 추가
 */
router.post('/specific/add', async (req, res) => {
  try {
    const { codes } = req.body;

    // 유효성 검사
    if (!Array.isArray(codes) || codes.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'codes must be a non-empty array'
      });
    }

    if (codes.length > 100) {
      return res.status(400).json({
        success: false,
        error: 'Maximum 100 stocks allowed'
      });
    }

    // 종목 코드 형식 검증
    const stockFilter = new StockFilter();
    const invalidCodes = codes.filter(code => !stockFilter.isValidStockCode(code));
    if (invalidCodes.length > 0) {
      return res.status(400).json({
        success: false,
        error: `Invalid stock codes: ${invalidCodes.join(', ')}`
      });
    }

    // 저장
    const configRepo = new ConfigRepository();
    await configRepo.updateStockMode('specific');
    await configRepo.updateSpecificStocks(codes);

    const selectedStocks = await configRepo.getSpecificStocks();

    res.json({
      success: true,
      selected_count: selectedStocks.length,
      selected_stocks: selectedStocks
    });
  } catch (error) {
    console.error('/api/stocks/specific/add error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * GET /api/stocks/specific
 * 특정 종목 조회
 */
router.get('/specific', async (req, res) => {
  try {
    const configRepo = new ConfigRepository();
    const currentMode = await configRepo.getStockMode();
    const selectedStocks = await configRepo.getSpecificStocks();

    res.json({
      current_mode: currentMode,
      selected_count: selectedStocks.length,
      selected_stocks: selectedStocks
    });
  } catch (error) {
    console.error('/api/stocks/specific error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * DELETE /api/stocks/specific/:code
 * 특정 종목 제거
 */
router.delete('/specific/:code', async (req, res) => {
  try {
    const { code } = req.params;

    const configRepo = new ConfigRepository();
    let selectedStocks = await configRepo.getSpecificStocks();
    
    selectedStocks = selectedStocks.filter(c => c !== code);
    await configRepo.updateSpecificStocks(selectedStocks);

    res.json({
      success: true,
      selected_count: selectedStocks.length
    });
  } catch (error) {
    console.error('/api/stocks/specific/:code error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
```

---

## 7. 시퀀스 다이어그램 (특정 종목 선택 → 백테스팅)

```
FrontEnd                API           DataManager    StockFilter      DB
  |                      |                 |               |           |
  |--POST /stocks/mode-->|                 |               |           |
  |                      |                 |               |           |
  |                      |--updateStockMode()               |           |
  |                      |                 |               |           |
  |                      |                 |               |--UPDATE------|
  |                      |<--Response------|               |   stock_mode |
  |<--200 OK-------------|                 |               |           |
  |                      |                 |               |           |
  |--POST /stocks/specific/add-->|         |               |           |
  |  { codes: ['005930', ...] }            |               |           |
  |                      |                 |               |           |
  |                      |--updateSpecific()               |           |
  |                      |                 |               |           |
  |                      |                 |               |--UPDATE------|
  |                      |                 |               | selected_... |
  |                      |<--Response------|               |           |
  |<--200 OK (2 selected)|                 |               |           |
  |                      |                 |               |           |
  |-POST /backtest/start-|                 |               |           |
  | { stockMode: 'specific' |              |               |           |
  |   selectedStocks: [...] }|              |               |           |
  |                      |                 |               |           |
  |                      |--getBacktestStocks()            |           |
  |                      |                 |--getSpecific()->|        |
  |                      |                 |<--['005930'...]|        |
  |                      |                 |               |           |
  |                      |<--['005930', '000660']          |           |
  |                      |                 |               |           |
  | (WebSocket: progress)|--applyFilter('specific', ...)---|---------->|
  |(0/2 completed)       |                 |               |<---------|
  |                      |                 |               |Filtered  |
  |                      |<--['005930', '000660']          |           |
  |                      |                 |               |           |
  | (BacktestEngine.start() with filtered stocks)          |           |
  |  - 삼성전자 백테스팅 시작            |               |           |
  | (WebSocket: 1/2)     |                 |               |           |
  |  - SK하이닉스 백테스팅 시작         |               |           |
  | (WebSocket: 2/2 완료)|                 |               |           |
  |                      |                 |               |           |
  |--GET /backtest/result/{id}----->|     |               |           |
  |                      |                 |               |           |
  |<--200 OK (결과들)    |                 |               |           |
  | stock_mode: 'specific'|               |               |           |
  | selected_stocks: [...] |              |               |           |
```

---

## 8. 예외처리 및 에러 코드

| 에러 코드 | 메시지 | HTTP 상태 | 원인 |
|----------|--------|----------|------|
| ERR-001 | Invalid stock_mode | 400 | 요청 파라미터 오류 |
| ERR-002 | Invalid stock code format | 400 | 종목 코드 형식 오류 (6자리 숫자 아님) |
| ERR-003 | Stock code not found | 404 | 종목 코드가 KOSPI 200 또는 화이트리스트에 없음 |
| ERR-004 | Maximum stocks exceeded | 400 | 선택 종목 수 초과 (100개) |
| ERR-005 | Database error | 500 | DB 저장 실패 |
| ERR-006 | Backtest execution failed | 500 | 백테스트 엔진 오류 |

---

## 9. 수도코드 (특정 종목 필터링)

```
function applySpecificFilter(requestedStocks, kospi200List, whitelistStocks) {
  // 1. 입력 검증
  for each stock in requestedStocks {
    if not isValidStockCode(stock) {
      throw StockValidationError(stock)
    }
  }

  // 2. KOSPI 200 또는 화이트리스트에 속하는지 확인
  validStocks = []
  for each stock in requestedStocks {
    if stock in kospi200List OR stock in whitelistStocks {
      add stock to validStocks
    } else {
      log warning: stock not in KOSPI 200 or whitelist
    }
  }

  // 3. 중복 제거
  return unique(validStocks)
}
```

---

## 변경 이력

| 버전 | 작성자 | 작성일 | 변경 사항 |
|------|--------|--------|---------|
| 1.0 | LLD_담당자 | 2026-02-08 | 9개 컴포넌트 설계 (초기 버전) |
| 2.0 | LLD_담당자 | 2026-02-08 | **StockFilter 신규**, **ConfigRepository/DataManager/BacktestEngine 확장**, **4개 API 엔드포인트** |

---

## 다음 단계
- 실무 개발자: LLD 2.0 기반 코드 개발 (TICKET-010)
  - backend/modules/StockFilter.js
  - backend/repositories/ConfigRepository.js 확장
  - backend/services/DataManager.js 확장
  - backend/routes/stocks.js
  - SQL 마이그레이션
  - 프론트엔드 UI 개발
